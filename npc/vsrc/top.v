// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifdef RANDOMIZE_REG_INIT
  `define RANDOMIZE
`endif // RANDOMIZE_REG_INIT

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifdef RANDOMIZE
  `ifdef VERILATOR
    `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
  `else  // VERILATOR
    `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
  `endif // VERILATOR
`else  // RANDOMIZE
  `define INIT_RANDOM_PROLOG_
`endif // RANDOMIZE

// external module sim_sram

module IF_pre_fetch(	// <stdin>:25:10
  input         clock,
                reset,
  output [63:0] io_PF_pc,
                io_PF_npc,
  output [31:0] axi_lite_readAddr_bits_addr);

  reg [63:0] PF_npc;	// pre_fetch.scala:20:27
  reg [63:0] rhsReg;	// tools.scala:32:33
  always @(posedge clock) begin
    if (reset) begin
      PF_npc <= 64'h80000000;	// pre_fetch.scala:20:27
      rhsReg <= 64'h0;	// tools.scala:32:33
    end
    else begin
      PF_npc <= PF_npc + 64'h4;	// pre_fetch.scala:20:27, :24:34
      rhsReg <= PF_npc;	// pre_fetch.scala:20:27, tools.scala:32:33
    end
  end // always @(posedge)
  `ifndef SYNTHESIS	// <stdin>:25:10
    `ifdef FIRRTL_BEFORE_INITIAL	// <stdin>:25:10
      `FIRRTL_BEFORE_INITIAL	// <stdin>:25:10
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin	// <stdin>:25:10
      automatic logic [31:0] _RANDOM_0;	// <stdin>:25:10
      automatic logic [31:0] _RANDOM_1;	// <stdin>:25:10
      automatic logic [31:0] _RANDOM_2;	// <stdin>:25:10
      automatic logic [31:0] _RANDOM_3;	// <stdin>:25:10
      automatic logic [31:0] _RANDOM_4;	// <stdin>:25:10
      `ifdef INIT_RANDOM_PROLOG_	// <stdin>:25:10
        `INIT_RANDOM_PROLOG_	// <stdin>:25:10
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// <stdin>:25:10
        _RANDOM_0 = `RANDOM;	// <stdin>:25:10
        _RANDOM_1 = `RANDOM;	// <stdin>:25:10
        _RANDOM_2 = `RANDOM;	// <stdin>:25:10
        _RANDOM_3 = `RANDOM;	// <stdin>:25:10
        _RANDOM_4 = `RANDOM;	// <stdin>:25:10
        PF_npc = {_RANDOM_0, _RANDOM_1};	// pre_fetch.scala:20:27
        rhsReg = {_RANDOM_2[31:1], _RANDOM_3, _RANDOM_4[0]};	// tools.scala:32:33
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// <stdin>:25:10
      `FIRRTL_AFTER_INITIAL	// <stdin>:25:10
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  assign io_PF_pc = rhsReg;	// <stdin>:25:10, tools.scala:32:33
  assign io_PF_npc = PF_npc;	// <stdin>:25:10, pre_fetch.scala:20:27
  assign axi_lite_readAddr_bits_addr = PF_npc[31:0];	// <stdin>:25:10, pre_fetch.scala:20:27, :44:46
endmodule

module IFU(	// <stdin>:79:10
  input         clock,
                reset,
  output [63:0] io_PF_npc,
                io_PF_pc);

  wire [63:0] _pre_fetch_io_PF_pc;	// IFU.scala:52:27
  wire [31:0] _pre_fetch_axi_lite_readAddr_bits_addr;	// IFU.scala:52:27
  wire        _inst_ram_arready;	// IFU.scala:51:26
  wire [63:0] _inst_ram_rdata;	// IFU.scala:51:26
  wire [1:0]  _inst_ram_rresp;	// IFU.scala:51:26
  wire        _inst_ram_rvalid;	// IFU.scala:51:26
  wire        _inst_ram_awready;	// IFU.scala:51:26
  wire        _inst_ram_wready;	// IFU.scala:51:26
  wire [1:0]  _inst_ram_bresp;	// IFU.scala:51:26
  wire        _inst_ram_bvalid;	// IFU.scala:51:26
  sim_sram inst_ram (	// IFU.scala:51:26
    .pc      (_pre_fetch_io_PF_pc),	// IFU.scala:52:27
    .aclk    (clock),
    .aresetn (~reset),	// IFU.scala:66:48
    .araddr  (_pre_fetch_axi_lite_readAddr_bits_addr),	// IFU.scala:52:27
    .arvalid (1'h1),	// <stdin>:79:10
    .rready  (1'h1),	// <stdin>:79:10
    .awaddr  (32'h0),	// <stdin>:79:10
    .awvalid (1'h0),	// <stdin>:79:10
    .wdata   (64'h0),	// <stdin>:79:10
    .wstrb   (8'h0),	// IFU.scala:52:27
    .wvalid  (1'h0),	// <stdin>:79:10
    .bready  (1'h0),	// <stdin>:79:10
    .arready (_inst_ram_arready),
    .rdata   (_inst_ram_rdata),
    .rresp   (_inst_ram_rresp),
    .rvalid  (_inst_ram_rvalid),
    .awready (_inst_ram_awready),
    .wready  (_inst_ram_wready),
    .bresp   (_inst_ram_bresp),
    .bvalid  (_inst_ram_bvalid)
  );
  IF_pre_fetch pre_fetch (	// IFU.scala:52:27
    .clock                       (clock),
    .reset                       (reset),
    .io_PF_pc                    (_pre_fetch_io_PF_pc),
    .io_PF_npc                   (io_PF_npc),
    .axi_lite_readAddr_bits_addr (_pre_fetch_axi_lite_readAddr_bits_addr)
  );
  assign io_PF_pc = _pre_fetch_io_PF_pc;	// <stdin>:79:10, IFU.scala:52:27
endmodule

// external module LSU

module MEMU();	// <stdin>:1234:10
  wire [63:0] _mem_ReadData;	// MEMU.scala:50:21
  LSU mem (	// MEMU.scala:50:21
    .pc        (64'h0),	// <stdin>:1234:10
    .addr      (64'h0),	// <stdin>:1234:10
    .LsuType   (5'h0),	// <stdin>:1234:10
    .WriteEn   (1'h0),	// <stdin>:1234:10
    .ReadEn    (1'h0),	// <stdin>:1234:10
    .WriteData (64'h0),	// <stdin>:1234:10
    .ReadData  (_mem_ReadData)
  );
endmodule

// external module sim

module top(	// <stdin>:1307:10
  input         clock,
                reset,
  output [63:0] io_ID_npc,
                io_PF_npc,
                io_PF_pc,
                io_IF_pc,
                io_ID_pc,
                io_EX_pc,
                io_WB_pc,
  output [31:0] io_WB_Inst,
  output [63:0] io_WB_RegWriteData,
                io_WB_RegWriteID,
  output        io_WB_valid,
  output [63:0] io_MEM_RegWriteData,
  output        io_stall,
  output [31:0] io_IF_Inst,
  output        io_IF_valid,
  output [63:0] io_ID_ALU_Data1,
                io_ID_ALU_Data2,
                io_ID_Rs1Data,
                io_ID_Rs2Data,
                io_ALUResult);

  wire [63:0] _simulate_inst;	// top.scala:74:26
  IFU inst_fetch_unit (	// top.scala:45:33
    .clock     (clock),
    .reset     (reset),
    .io_PF_npc (io_PF_npc),
    .io_PF_pc  (io_PF_pc)
  );
  MEMU mem_unit ();	// top.scala:48:26
  sim simulate (	// top.scala:74:26
    .clock             (1'h0),	// top.scala:74:26
    .reset             (1'h0),	// top.scala:74:26
    .IF_pc             (64'h0),	// top.scala:74:26
    .GPR_0             (64'h0),	// top.scala:74:26
    .GPR_1             (64'h0),	// top.scala:74:26
    .GPR_2             (64'h0),	// top.scala:74:26
    .GPR_3             (64'h0),	// top.scala:74:26
    .GPR_4             (64'h0),	// top.scala:74:26
    .GPR_5             (64'h0),	// top.scala:74:26
    .GPR_6             (64'h0),	// top.scala:74:26
    .GPR_7             (64'h0),	// top.scala:74:26
    .GPR_8             (64'h0),	// top.scala:74:26
    .GPR_9             (64'h0),	// top.scala:74:26
    .GPR_10            (64'h0),	// top.scala:74:26
    .GPR_11            (64'h0),	// top.scala:74:26
    .GPR_12            (64'h0),	// top.scala:74:26
    .GPR_13            (64'h0),	// top.scala:74:26
    .GPR_14            (64'h0),	// top.scala:74:26
    .GPR_15            (64'h0),	// top.scala:74:26
    .GPR_16            (64'h0),	// top.scala:74:26
    .GPR_17            (64'h0),	// top.scala:74:26
    .GPR_18            (64'h0),	// top.scala:74:26
    .GPR_19            (64'h0),	// top.scala:74:26
    .GPR_20            (64'h0),	// top.scala:74:26
    .GPR_21            (64'h0),	// top.scala:74:26
    .GPR_22            (64'h0),	// top.scala:74:26
    .GPR_23            (64'h0),	// top.scala:74:26
    .GPR_24            (64'h0),	// top.scala:74:26
    .GPR_25            (64'h0),	// top.scala:74:26
    .GPR_26            (64'h0),	// top.scala:74:26
    .GPR_27            (64'h0),	// top.scala:74:26
    .GPR_28            (64'h0),	// top.scala:74:26
    .GPR_29            (64'h0),	// top.scala:74:26
    .GPR_30            (64'h0),	// top.scala:74:26
    .GPR_31            (64'h0),	// top.scala:74:26
    .unknown_inst_flag (1'h0),	// top.scala:74:26
    .WB_Inst           (32'h0),	// top.scala:74:26
    .inst              (_simulate_inst)
  );
  assign io_ID_npc = 64'h4;	// <stdin>:1307:10, top.scala:46:34
  assign io_IF_pc = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_ID_pc = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_EX_pc = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_WB_pc = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_WB_Inst = 32'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_WB_RegWriteData = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_WB_RegWriteID = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_WB_valid = 1'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_MEM_RegWriteData = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_stall = 1'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_IF_Inst = 32'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_IF_valid = 1'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_ID_ALU_Data1 = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_ID_ALU_Data2 = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_ID_Rs1Data = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_ID_Rs2Data = 64'h0;	// <stdin>:1307:10, top.scala:74:26
  assign io_ALUResult = 64'h0;	// <stdin>:1307:10, top.scala:74:26
endmodule


// ----- 8< ----- FILE "./build/sim_sram.v" ----- 8< -----

import "DPI-C" function void dci_pmem_write(input longint waddr, input longint wdata, input byte wmask);
import "DPI-C" function void dci_pmem_read(input longint raddr, output longint rdata, input byte rmask);

module sim_sram(
    input       [63:0]      pc          ,         //for debug
    input                   aresetn     ,
    input                   aclk        ,
    //ar
    input       [31:0]      araddr      ,
    input                   arvalid     ,
    output reg              arready     ,
    //r
    output reg  [63:0]      rdata       ,
    output reg  [1: 0]      rresp       ,
    output reg              rvalid      ,
    input                   rready      ,
    //aw
    input       [31:0]      awaddr      ,
    input                   awvalid     ,
    output reg              awready     , 
    //w
    input       [63:0]      wdata       , 
    input       [7: 0]      wstrb       ,
    input                   wvalid      ,
    output reg              wready      ,
    //b
    output reg  [1: 0]      bresp       ,
    output reg              bvalid      ,
    input                   bready
);

    reg arready_r, rvalid_r, awready_r, wready_r, bvalid_r;
    reg [1:0] rresp_r, bresp_r;
    reg [63:0] rdata_r;

    reg [31:0] araddr_r;

    assign arready = arready_r;
    assign rvalid = rvalid_r;
    assign awready = awready_r;
    assign wready = wready_r;
    assign bvalid = bvalid_r;
    assign rresp = rresp_r;
    assign bresp = bresp_r;
    assign rdata = rdata_r;

    //ar
    always@(posedge aclk) begin
        if(!aresetn) begin
            arready_r <= 1'b1;
            araddr_r  <= 32'b0;
        end
        else if(arvalid) begin
            arready_r <= 1'b1;
            araddr_r <= araddr;
        end
        else 
            arready_r <= 1'b1;
    end

    always@(posedge aclk) begin
        if(!aresetn) begin
            rvalid_r <= 1'b0;
            rresp_r  <= 2'b0;
        end
        else begin
            if(arready_r & arvalid) begin
                rvalid_r <= 1'b1;
                rresp_r  <= 2'b00;
            end
            else if(rvalid_r & rready) begin
                rvalid_r <= 1'b0;
            end
        end 
    end

    always@(posedge aclk) begin
        if(!aresetn) begin
            rdata_r = 64'b0;
        end
        else begin
            if(arready_r & arvalid)
                dci_pmem_read({32'H000, araddr_r}, rdata_r, 8'HFF);
        end
        // $display("addr:0x%x, rdata:0x%x", araddr_r, rdata_r);
    end

endmodule

// ----- 8< ----- FILE "./build/LSU.v" ----- 8< -----

// import "DPI-C" function void dci_pmem_write(input longint waddr, input longint wdata, input byte wmask);
// import "DPI-C" function void dci_pmem_read(input longint raddr, output longint rdata, input byte rmask);

module LSU(input [63:0] pc, input [63:0] addr, input [4:0] LsuType, input WriteEn, input ReadEn, input [63:0]WriteData, output [63:0] ReadData);

    wire [7:0] mask;
    wire [63:0] lw_result;
    wire [63:0] lh_result;
    wire [63:0] lb_result;
    reg [63:0] data_r;

    wire lw_flag = LsuType[0] && ((mask ^ 8'h0F) == 8'b0);
    wire lh_flag = LsuType[0] && ((mask ^ 8'h03) == 8'b0);
    wire lb_flag = LsuType[0] && ((mask ^ 8'h01) == 8'b0);
    assign mask = ~(8'hFF << LsuType[4:1]);
    assign lw_result = {{32{data_r[31]}}, data_r[31:0]};
    assign lh_result = {{48{data_r[15]}}, data_r[15:0]};
    assign lb_result = {{56{data_r[7]}}, data_r[7:0]};
    assign ReadData = lw_flag     ? lw_result :
                      lh_flag     ? lh_result :
                      lb_flag     ? lb_result : data_r;

        always@(*) begin
            if(WriteEn) begin
                dci_pmem_write(addr, WriteData, mask);
                data_r = 64'h0;
            end
            else if(ReadEn)begin
                dci_pmem_read(addr, data_r, mask);
            end
            else
                data_r = 64'b0;
        end
endmodule

// ----- 8< ----- FILE "./build/sim.v" ----- 8< -----

import "DPI-C" function void set_gpr_ptr(input logic [63:0] a []);
import "DPI-C" function void unknown_inst();
import "DPI-C" function void ebreak(input longint halt_ret);


wire [63:0] GPR [31:0];
assign {GPR[31], GPR[30], GPR[29], GPR[28], GPR[27], GPR[26], GPR[25], GPR[24], GPR[23], GPR[22], GPR[21], GPR[20]
, GPR[19], GPR[18], GPR[17], GPR[16], GPR[15], GPR[14], GPR[13], GPR[12], GPR[11], GPR[10], GPR[9], GPR[8], GPR[7]
, GPR[6], GPR[5], GPR[4], GPR[3], GPR[2], GPR[1], GPR[0]} = 
{{_inst_decode_unit_io_ID_GPR_31}, {_inst_decode_unit_io_ID_GPR_30}, {_inst_decode_unit_io_ID_GPR_29}, 
{_inst_decode_unit_io_ID_GPR_28}, {_inst_decode_unit_io_ID_GPR_27}, {_inst_decode_unit_io_ID_GPR_26}, {_inst_decode_unit_io_ID_GPR_25}, 
{_inst_decode_unit_io_ID_GPR_24}, {_inst_decode_unit_io_ID_GPR_23}, {_inst_decode_unit_io_ID_GPR_22}, {_inst_decode_unit_io_ID_GPR_21}, 
{_inst_decode_unit_io_ID_GPR_20}, {_inst_decode_unit_io_ID_GPR_19}, {_inst_decode_unit_io_ID_GPR_18}, {_inst_decode_unit_io_ID_GPR_17}, 
{_inst_decode_unit_io_ID_GPR_16}, {_inst_decode_unit_io_ID_GPR_15}, {_inst_decode_unit_io_ID_GPR_14}, {_inst_decode_unit_io_ID_GPR_13}, 
{_inst_decode_unit_io_ID_GPR_12}, {_inst_decode_unit_io_ID_GPR_11}, {_inst_decode_unit_io_ID_GPR_10}, {_inst_decode_unit_io_ID_GPR_9 }, 
{_inst_decode_unit_io_ID_GPR_8 }, {_inst_decode_unit_io_ID_GPR_7 }, {_inst_decode_unit_io_ID_GPR_6 }, {_inst_decode_unit_io_ID_GPR_5 },
{_inst_decode_unit_io_ID_GPR_4 }, {_inst_decode_unit_io_ID_GPR_3 }, {_inst_decode_unit_io_ID_GPR_2 }, {_inst_decode_unit_io_ID_GPR_1 }, 
{_inst_decode_unit_io_ID_GPR_0}};	// IDU.scala:55:22, :66:20

sim simulate (	// top.scala:24:26
   .IF_pc             (_inst_fetch_unit_io_IF_pc),	// top.scala:24:33
   .WB_Inst           (io_WB_Inst),
   .GPR               (GPR),
   .unknown_inst_flag(_inst_decode_unit_io_ID_unknown_inst)
);

module sim(input[63:0] IF_pc, input [63:0] GPR [31:0], input unknown_inst_flag, input[31:0] WB_Inst);

   initial begin
      if ($test$plusargs("trace") != 0) begin
         $display("[%0t] Tracing to logs/vlt_dump.vcd...\n", $time);
         $dumpfile("logs/vlt_dump.vcd");
         $dumpvars();
      end
      $display("[%0t] Model running...\n", $time);
   end

   initial set_gpr_ptr(GPR);    // rf为通用寄存器的二维数组变量

  always@(*) begin
      reg [63:0] i = GPR[10][63:0];
      if(unknown_inst_flag) unknown_inst();
      if(WB_Inst[31:0] == 32'h00100073) begin
        ebreak(i);
        $finish();
      end
  end

endmodule

// ----- 8< ----- FILE "firrtl_black_box_resource_files.f" ----- 8< -----

build/build/LSU.v
build/build/sim.v
build/build/sim_sram.v
